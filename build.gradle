plugins {
    id 'java'
}

def props = new Properties()
file("gradle.properties").withInputStream { props.load(it) }

group = 'com.mkso4ka.mindustry.matrixproc'
version = props.getProperty("modVersion", "1.0-SNAPSHOT")

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

ext {
    mindustryVersion = "v147"
    isWindows = System.getProperty("os.name").toLowerCase().contains("windows")
}

sourceCompatibility = 17

// Репозитории теперь нужны только для Mindustry API
repositories {
    mavenCentral()
    maven { url "https://raw.githubusercontent.com/Zelaux/MindustryRepo/master/repository" }
    maven { url "https://raw.githubusercontent.com/Anuken/Mindustry/mvn-repo/repository" }
}

dependencies {
    // API игры, которое будет доступно при компиляции, но не войдет в итоговый JAR
    compileOnly "com.github.Anuken.Mindustry:core:${mindustryVersion}"
    compileOnly "com.github.Anuken.Arc:arc-core:${mindustryVersion}"
    
    // Ваши зависимости, которые ВОЙДУТ в итоговый JAR (так как их нет в игре)
    implementation fileTree(dir: 'libs', include: ['*.jar'])
}

processResources {
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
    // Говорим Gradle: "Найди файл mod.hjson в ресурсах и примени к нему фильтр"
    filesMatching('mod.hjson') {
        filter(org.apache.tools.ant.filters.ReplaceTokens, tokens: [
            VERSION: project.version
        ])
    }
}

// --- ИСПРАВЛЕННАЯ ЗАДАЧА JAR ---
// Теперь она собирает "правильный" JAR, а не "толстый"
jar {
    archiveBaseName = project.name
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    // 1. Добавляем скомпилированные классы и ресурсы нашего мода
    from sourceSets.main.output

    // 2. КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: Используем runtimeClasspath.
    // Это включает только 'implementation' зависимости (ваши JAR-файлы из папки libs),
    // но ИГНОРИРУЕТ 'compileOnly' зависимости (Mindustry API), что резко уменьшает размер.
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
}

// Эта задача берет "правильный" JAR и конвертирует все классы в classes.dex
task createDex(type: Exec) {
    dependsOn 'jar'
    // Находим утилиту d8 в Android SDK
    def d8 = new File(System.getenv("ANDROID_HOME"), "build-tools/${findLatestBuildTools()}/d8" + (isWindows ? ".bat" : ""))
    
    // Указываем, куда положить результат
    def dexOutput = new File(buildDir, "dex/classes.dex")
    
    doFirst {
        // Убеждаемся, что директория существует
        dexOutput.parentFile.mkdirs()
    }

    // Запускаем d8, передавая ему наш JAR и путь для выходного файла
    commandLine d8, "--release", "--output", dexOutput, tasks.jar.archiveFile.get().asFile
}

// Задача deploy теперь собирает финальный, универсальный JAR для PC и Android
task deploy(type: Jar, dependsOn: createDex) {
    // Финальное имя файла без версий и классификаторов
    archiveBaseName = "PictureToLogic"
    archiveClassifier = null
    archiveVersion = '' 

    duplicatesStrategy = DuplicatesStrategy.INCLUDE

    // 1. Включаем ресурсы (mod.hjson)
    from sourceSets.main.resources
    
    // 2. Включаем ресурсы из наших зависимостей (например, LICENSE файлы), но не их классы
    from(configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it).matching{
        exclude '**/*.class'
    }})

    // 3. Добавляем в корень архива созданный classes.dex
    from(new File(buildDir, "dex")) {
        into '/'
    }

    doLast {
        println "Successfully built universal JAR at: ${archiveFile.get().asFile.path}"
    }
}

// Вспомогательная функция для поиска последней версии build-tools
String findLatestBuildTools(){
    def buildTools = new File(System.getenv("ANDROID_HOME"), "build-tools")
    if(!buildTools.exists()) return ""
    return buildTools.listFiles().sort{ a, b ->
        b.name.replace("-preview", ".0").compareTo(a.name.replace("-preview", ".0"))
    }[0].name
}